/**<!-------------------------------------------------------------------->
   @file   MLTLensSubpathMutation.cpp
   @author Travis Fischer (fisch0920@gmail.com)
   @date   Spring 2009
   
   @brief
      Lens Subpath mutations aim to stratify samples over the image plane. 
   Each mutation consists of deleting the lens subpath of the current path 
   and replacing it by a new one (lens subpaths are of the form ((L|D)S*)+E).
   Lens subpaths are stratified across the image plane using a pseudo-random 
   rover pattern generated by DissolveSampleGeneratorThread.
   
   @see p. 354-355 of Veach's thesis (section 11.4.4)
   <!-------------------------------------------------------------------->**/

#include "MLTLensSubpathMutation.h"
#include <RenderOutput.h>
#include <Camera.h>
#include <QtCore/QtCore>
#include <mlt.h>

namespace milton {

MLTLensSubpathMutation::~MLTLensSubpathMutation() {
   safeDelete(m_generator);
   safeDeleteArray(m_noSamples);
}

void MLTLensSubpathMutation::init() {
   if (NULL == m_generator)
      m_generator = new DissolveSampleGeneratorThread();
   
   safeDeleteArray(m_noSamples);
}

real_t MLTLensSubpathMutation::mutate(const Path &X, Path &Y) {
   const unsigned n = X.length();
   Path lens(m_renderer);
   Y = X;
   
   { // delete current lens subpath
      ASSERT(Y.front().isEmitter());
      ASSERT(Y.back() .isSensor());
      
      do {
         do { // remove previous sensor vertex and zero or more specular vertices
            Y.pop_back();
         } while(Y.back().bsdf->isSpecular());
         
         if (Y.empty())
            return 0;   // mutation failed
         
         Y.pop_back();
      } while(!Y.empty() && Y.back().bsdf->isSpecular());
   }
   
   { // determine new point on image plane
      const Viewport &viewport = m_renderer->getOutput()->getViewport();
      const real_t pA = viewport.getInvWidth() * viewport.getInvHeight();
      Point2 filmPt;
      
#if 1
      const unsigned size   = viewport.getSize();
      const unsigned width  = viewport.getWidth();
      const unsigned height = viewport.getHeight();
      
      if (NULL == m_noSamples) {
         m_noSamples = new unsigned[size];
         memset(m_noSamples, 0, sizeof(unsigned) * size);
         
         m_maxSamples = 1;
         m_curSamples = 0;
      }
      
      unsigned col = Random::sampleInt(0, width);
      unsigned row = Random::sampleInt(0, height);
      
      // attempt to stratify lens subpaths across the image plane
      do {
         if (m_noSamples[row * width + col] < m_maxSamples) {
            if (++m_noSamples[row * width + col] == m_maxSamples)
               ++m_curSamples;
            
            break;
         } else if (++m_curSamples >= size) {
            ++m_noSamples[row * width + col];
            m_maxSamples = m_noSamples[row * width + col] + 1;
            m_curSamples = 0;
            
            break;
         } else { // search for a non-full pixel with a pseudo-random rover
            m_generator->generate(filmPt, viewport);
            
            col = filmPt[0] * width;
            row = filmPt[1] * height;
            col = MIN(col, width  - 1);
            row = MIN(row, height - 1);
         }
      } while(1);
      
      filmPt[0] = (col + Random::sample(0, 1)) * viewport.getInvWidth();
      filmPt[1] = (row + Random::sample(0, 1)) * viewport.getInvHeight();
#else
      // no stratification
      filmPt[0] = Random::sample(0, 1);
      filmPt[1] = Random::sample(0, 1);
      
      // noticeable patterns tend to appear when using the pseudo-random rover 
      // only, so we instead try random first and only use the pseudo-random 
      // rover once we reach a 'full' pixel to deterministically find a non-full 
      // pixel
      //m_generator->generate(filmPt, viewport);
#endif
      
      SurfacePoint *pt = new SurfacePoint();
      m_renderer->getCamera()->getPoint(*pt, UV(filmPt));
      lens.prepend(PathVertex(pt, 1, pA));
   }
   
   const unsigned s = Y.length();
   
   do {
      do { // prepend vertices until we reach a non-specular vertex
         if (!lens.prepend(false, false))
            return 0; // mutation failed
         
         if (lens.length() > n)
            return 0; // mutation failed
         
         if (lens.front().pt->shape->getMaterial() != 
             X[n - lens.length()].pt->shape->getMaterial())
         {
            return 0; // mutation failed
         }
         
         lens.front().bsdf->setWi(lens.front().wi);
         lens.front().event = 
            lens.front().bsdf->sample(X[n - lens.length()].event);
      } while(lens.front().bsdf->isSpecular() && s + lens.length() < n);
   } while(s + lens.length() < n);
   
   { // attempt to join old subpath with new lens subpath
      if (!Y.append(lens))
         return 0;    // mutation failed
      
      if (!Y.front().isEmitter() || !Y.back().isSensor())
         return 0;    // mutation failed
   }
   
   const real_t Fx  = X.getRadiance().getRGB().luminance();
   const real_t Txy = Y[s].pE;
   const real_t den = Txy * Fx;
   
   if (den == 0)
      return 0;         // mutation failed
   
   const real_t Fy  = Y.getRadiance().getRGB().luminance();
   const real_t Tyx = X[s].pE;
   
// TODO:  #warning "TESTING"
   const real_t a = ((Y.getRadiance()/X.getRadiance()).getRGB()).luminance() * (Tyx/Txy);
   return MIN(1.0, a);
// TODO:  #warning "TESTING"
   
   return MIN(1.0, (Fy * Tyx) / den);
}

#if 0
real_t MLTLensSubpathMutation::getPd(const Event &event) {
   Path Y = event.getValue<const Path&>();
   Path y = Y;
   Path x = m_path;
   
   if (x.length() < 2 || y.length() < 2)
      return 0;
   
   { // delete current lens subpaths
      ASSERT(x.front().isEmitter());
      ASSERT(x.back() .isSensor());
      ASSERT(y.front().isEmitter());
      ASSERT(y.back() .isSensor());
      
      do {
         x.pop_back();
      } while(x.back().bsdf->isSpecular());
      
      do {
         y.pop_back();
      } while(y.back().bsdf->isSpecular());
      
      if (y.empty() || x.empty())
         return 0; // invalid mutation
      
      y.pop_back();
      x.pop_back();
   }
   
   // ensure non-lens subpaths match up
   if (x != y)
      return 0;    // invalid mutation
   
   const unsigned s = y.length();
   
#if 0
   SpectralSampleSet f = SpectralSampleSet::identity();
   real_t p = Y[s].pE;
   for(unsigned i = s - 1; i < Y.length(); ++i)
      f *= Y[i].fs * Y[i].GL;
   
   const real_t luminance = f.getRGB().luminance();
   if (luminance == 0)
      return 0;
   return p / luminance;
#else
#if 1
#warning "testing 1e with both bidir and lens subpaths"
   const real_t luminance = Y.getRadiance().getRGB().luminance();
   const real_t p = Y[s].pE;
   
   if (luminance <= 0)
      return 0;
   
   return p / luminance;
#else
   const unsigned t = Y.length() - s;
   const SpectralSampleSet &radiance = Y.getContribution(s, t);
   const real_t luminance = radiance.getRGB().luminance();
   
   if (luminance == 0)
      return 0;
   
   return 1.0 / luminance;
#endif
#endif
}
#endif

// old, unused
#if 0
   if (Y.length() != s + t)
      cerr << "error: " << s << ", " << t << ", " << Y.length() << endl;
   
   ASSERT(Y.length() == s + t);
   
   /*SpectralSampleSet f = SpectralSampleSet::identity();
   real_t p = Y[s - 1].pE;
   for(unsigned i = s - 1; i < Y.length(); ++i)
      f *= Y[i].fs * Y[i].GL;
   real_t Rxy = f.getRGB().luminance() / p;
   
   f = SpectralSampleSet::identity();
   p = X[s - 1].pE;
   for(unsigned i = s - 1; i < X.length(); ++i)
      f *= X[i].fs * X[i].GL;
   real_t Ryx = f.getRGB().luminance() / p;*/
   
   real_t Rxy = Y.getContribution(s, Y.length() - s).getRGB().luminance();
   real_t Ryx = X.getContribution(s, X.length() - s).getRGB().luminance();
   real_t alpha = (Ryx <= 0 ? 0 : MIN(1, Rxy / Ryx));
   
#warning "evaluate f.luminance() / p instead of (f/p).luminance()"
   
   return Event(Y, this, boost::any(), alpha);
#else
#if 0
   return Event(Y, this);
#endif

#endif

}

